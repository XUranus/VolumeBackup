#include "VolumeCopyMountProvider.h"

// external logger/json library
#include "Json.h"
#include "logger.h"
#include "VolumeUtils.h"

using namespace volumeprotect;
using namespace volumeprotect::mount;
using namespace volumeprotect::util;

// struct VolumeCopyMountConfig {
//     // where files generated by mounting process created
//     std::string     outputDirPath;
//     // requiring a copy name to decide the name of copy meta json
//     std::string     copyName;
//     // directory path of the volume copy meta
//     std::string     copyMetaDirPath;
//     // directory path of the volume copy data
//     std::string     copyDataDirPath;
//     // mount target path.
//     // For *nix loopback mount, the target directory must be created head
//     // For Windows virtual disk mount, it can keep empty to retrieve a drive letter automatically
//     std::string     mountTargetPath;

//     // optional fields....
//     // only used for *unix mount to sepecify filesystem type (option "-t", eg: ext4, xfs, btrfs...)
//     std::string     mountFsType;
//     // only used for *unix mount to sepecify mount options (option "-o", eg: "ro,loop,noatime")
//     std::string     mountOptions;      
// };


// factory function to load target copy mount provider, depending on which CopyFormat it is
std::unique_ptr<VolumeCopyMountProvider> VolumeCopyMountProvider::BuildVolumeCopyMountProvider(
    VolumeCopyMountConfig& mountConfig)
{
    VolumeCopyMeta volumeCopyMeta {};
    if (!util::ReadVolumeCopyMeta(mountConfig.copyMetaDirPath, mountConfig.copyName, volumeCopyMeta)) {
        ERRLOG("failed to read volume copy meta from %s, copy name %s",
            mountConfig.copyMetaDirPath.c_str(), mountConfig.copyName.c_str());
        return nullptr;
    }
    CopyFormat copyFormat = static_cast<CopyFormat>(volumeCopyMeta.copyFormat);
    switch (volumeCopyMeta.copyFormat) {
        case static_cast<int>(CopyFormat::BIN) : {

            break;
        }
        case static_cast<int>(CopyFormat::IMAGE) : {

            break;
        }
        case static_cast<int>(CopyFormat::VHD_DYNAMIC) :
        case static_cast<int>(CopyFormat::VHD_FIXED) :
        case static_cast<int>(CopyFormat::VHDX_DYNAMIC) :
        case static_cast<int>(CopyFormat::VHDX_FIXED) : {
            return 
            break;
        }
        default: ERRLOG("unknown copy format type %d", copyFormat);
    }
    return nullptr;
}

bool VolumeCopyMountProvider::IsMountSupported()
{
    // base class does not support mount
    return false;
}

bool VolumeCopyMountProvider::Mount() {
    // base class does not support mount
    return false;
}




std::unique_ptr<VolumeCopyUmountProvider> VolumeCopyUmountProvider::BuildVolumeCopyUmountProvider(
    const std::string mountRecordJsonFilePath
);

bool VolumeCopyUmountProvider::Umount();
